# 2.4 렌더링은 어떻게 일어나는가?

**2.4.1 리액트의 렌더링이란?**

브라우저의 렌더링 : 간단히 말해 HTML, CSS 기반 UI를 그리는 과정  
≠ 리액트의 렌더링 : 브라우저가 렌더링에 필요한 DOM 트리를 만드는 과정. (props, state 등을 적용)

리액트 자체적인 렌더링 프로세스가 있고, 이 렌더링 비용은 유저에게 청구되며, 시간이 길어지고 비용 증가하면 유저의 경험을 저해한다.  
따라서 렌더링이 어떻게, 왜, 어떤 순서로 일어나는지 알고 최소화해야한다.

<br>

**2.4.2 리액트의 렌더링이 일어나는 이유**

리액트 렌더링 시나리오. 이 외엔 렌더링이 일어나지 않는다.

1. 최초 렌더링

2. 리렌더링  
   (클래스형 예시 제외)  
   setState 실행 시  
   useReducer의 dispatch가 실행 시  
   부모로부터의 props가 변경될 시  
   컴포넌트의 key props가 변경 시  
   \***\*부모 컴포넌트가 렌더링/리렌더링 시**

> 참고)
> MobX, Redux는 각자의 방법으로 상태를 관리해주지만 이 상태 관리가 리액트의 리렌더링으로 이어지지 않음. mobx-react, react-redux 같은 리액트 패키지로 앞선 시나리오에 해당하는 방법으로 리렌더링 발생시킴.
> Recoil도 내부에서 useState 등을 통해 리렌더링을 발생시킴. (자세한 내용은 5.2절)

<br>

**2.4.3 리액트의 렌더링 프로세스**

리액트의 렌더링은 루트부터 아래쪽으로 내려간다.  
FunctionComponent() 자체를 호출(JSX문법임) → 자바스크립트로 컴파일 되면서 React.createElement()를 호출

ex)

```jsx
function HellO() { return (
<TestComponenta={35)b="yceffort"> 안녕하세요
</TestComponent> )
}

->

function HellO() {
retum React.createEIement(
TestComponent, {a:35,b:,yceffort'},
'안녕하세요', )
}

->

{type: TestComponent, props: {a: 35, b: "yceffort"> children: "안녕하세요"})
```

이런 결과물 수집 후, 새로 생성된 리액트의 가상 DOM과 실제 DOM의 변경사항을 수집  
→ 리액트의 재조정(Reconciliation) 이라고 한다. 이후 모든 변경 사항을 하나의 동기 시퀀스로 DOM에 적용되어 결과물을 만든다.

<br>

**2.4.4 렌더와 커밋**

위에서 말한 두 단계. 재조정과 DOM에 적용 → 리액트의 렌더링이 **렌더 단계**와 **커밋 단계**로 분리되는 듯

- 렌더 단계 : 컴포넌트를 렌더링하고 변경 사항을 계산하는 모든 작업
  컴포넌트 실행 (return) 후 이전의 가상 DOM과 비교해 변경이 필요한 컴포넌트를 체크
  비교하는 것은 크게 3가지. `type`, `props`, `key` (2.4.3의 코드 변환 최종에서의)
  이 중 하나라도 변경되면 변경 필요 컴포넌트로 체크
- 커밋 단계 : 변경 사항을 실제 DOM에 적용 → 브라우저의 렌더링이 발생

이후 useLayoutEffect 훅을 호출 (클래스형에서는 생명주기 메서드 호출)  
→ 중요한 점은 리액트 렌더링이 일어난다고 하여 무조건 DOM 업데이트가 일어나지 않음.

why? 퀴즈로~

<br>

> 참고)
> 리액트 렌더링(렌더, 커밋)은 동기식 작동. 그래서 렌더링 길어지면 앱 성능 저하.
> 비동기로 작동 시, 상태의 변경 순서에 따라 하나의 상태에 따라 다른 UI가 나옴…
> 그럼에도 비동기 렌더링이 유효한 경우 : B 컴포넌트가 무겁고 느려서 C라도 보여주는 것.
> (10.2절 리액트 18 동시성 렌더링, 비동기 렌더링)

<br>

**2.4.5 일반적인 렌더링 시나리오 살펴보기**

setState와 관련된 렌더링 시나리오(그림과 코드)가 있으니 궁금하면 책을 보면 될 것 같습니다.  
부모가 리렌더링 되면 props가 변경 되지 않아도 자식도 모두 리렌더링 관련 예시입니다.  
(퀴즈 1을 이해했다면 패스해도 될듯)

> 참고)
> 다만, props가 변경 되지 않았다면 자식 컴포넌트를 리렌더링 안하도록 막는 React.memo가 있다고 한다.

<br>
<br>

---

<br>
<br>

# 피드백

느낀점 : 나만 보는 요약인지, 다른 사람들이 책을 안 보고 이것만 봐도 이해가 되도록 하는 건지 고민이 되어 우선 요약을 이렇게 해봤음.

- [ ] 너무 길다. 더 요약해달라
- [ ] 지금 분량 딱 좋은 것 같다
- [ ] 질문이 있다 or 잘못된 내용이 있다

<br>

# 퀴즈

1. 다음 중 리액트 렌더링 / 리렌더링이 일어나지 않는 경우를 골라보시와요.  
   (부모 - 본인 - 자식 컴포넌트 관계에서 “본인”의 렌더링 / 리렌더링을 말함)

   1. 컴포넌트의 key props가 변경될 시

   2. 부모의 useState가 변경될 시

   3. 부모 컴포넌트의 useReducer의 두번째 인자인 dispatch가 실행될 시

   4. 자식의 useState가 변경될 시

   5. 부모에게서 오는 props가 변경될 시

정답 : \_\_

2.  리액트 렌더링이 일어난다고 하여 무조건 DOM 업데이트가 일어나지 않아요.  
    그리고 DOM 업데이트가 없다면 브라우저의 DOM 업데이트가 일어나지 않을 수 있습니다. 왜 그럴까요?  
    (2.4.4 챕터의 렌더, 커밋 단계를 참고하여)

정답 : \_\_

<br>

(Author: 마스터위)
