# 컴포넌트와 함수의 무거운 연산을 기억해두는 메모이제이션

이번 챕터는 React에서 제공하는 `useMemo`, `useCallback`, `memo와` 같은 메모이제이션 기법을 효율적으로 사용하여 렌더링을 최소화하는 방법에 대해 다룬다.

<br>

## 주장 1 : 섣부른 최적화는 독이다. 꼭 필요한 곳에만 메모이제이션을 추가하자.

### 근거 1. 메모이제이션도 비용이 드는 작업이다.

메모이제이션은 결과를 메모리에 저장해 두고 같은 동일한 계산이 재실행 될 때 메모리에서 그 값을 꺼내오도록 동작한다.

메모이제이션의 과정은 다음과 같다.

1. 전달받은 Props(Deps)와 이전의 PrevProps(prevDeps)에 대한 얕은 비교를 수행한다.
2. 변화가 없다면 이전의 value를 그대로 반환하고, 변화가 있다면 업데이트 된 value를 반환한다.
3. 연산 결과를 저장하기 위해 메모리를 사용한다.

(극단적인 예시로) 다음과 같은 간단한 연산을 생각해보자. 과연 메모이제이션의 비용이 저렴하다고 생각할 수 있을까?

``` javascript
function sum(a, b) {
  return a + b
}
```

<br>

### 근거 2. 리액트의 렌더링 성능은 충분히 빠르다.

리액트는 **Virtual DOM**과 **재조정(reconciliation) 알고리즘**으로 충분히 빠른 렌더링 성능을 제공한다.

- **Virtual DOM**<br>
  실제 DOM의 가벼운 사본으로, 컴포넌트의 변경사항은 실제 DOM에 바로 반영되는 대신, Virtual DOM에 먼저 반영된다.
- **재조정 알고리즘**<br>
  불필요한 DOM 조작을 최소화하기 위하여, 컴포넌트의 상태가 변경될 때마다 Virtual DOM에 먼저 반영한 후, 변경사항만을 실제 DOM과 동기화 한다. 

<br>

## 주장 2 : 렌더링 과정의 비용은 비싸다. 모조리 메모이제이션해 버리자.

### 근거 1. 일부 상황에서 메모이제이션은 분명히 도움이 된다.

메모이제이션을 사용할 때 우리에겐 두 가지 선택권이 있다.
- 컴포넌트에 따라 잘 살펴보고 적용하는 방법
- 그냥 일단 다 적용하는 방법

첫 번째 경우는 분명히 이상적인 상황이다. 그러나 프로젝트의 규모가 커지고 복잡성이 증가하는 상황에서도 전자의 기조를 유지할 수 있을까? 실무에서는 생각보다 최적화나 성능 향상에 쏟을 시간이 많지 않다.

### 근거 2. 어차피 리액트는 기본적으로 이전 결과물을 저장해둔다.

리액트의 기본적인 재조정 알고리즘은 이전 결과물을 저장하도록 동작한다. 따라서 메모이제이션으로 지불해야 하는 비용은 Props(Deps)에 대한 얕은 비교 뿐이다. 물론 Props(Deps)의 구조가 크고 복잡해진다면 이 비용 또한 커질 수 있다.

반면 메모이제이션을 하지 않았을 때 발생하는 비용은 다음과 같다. (다음은 memo의 경우이다.)

- 렌더링을 함으로써 발생하는 비용
- 컴포넌트 내부의 복잡한 로직의 재실행
- 위 두 가지가 모든 자식 컴포넌트에서도 반복해서 발생
- 리액트가 구 트리와 신규 트리를 비교 (Virtual DOM)

메모이제이션을 하지 않았을 때 치러야 할 잠재적인 위험 비용이 더 크다는 것을 알 수 있다. 비록 섣부른 최적화라 할 지라도 했을 때 누릴 수 있는 이점, 실수로 빠트렸을 때 치러야 할 위험 비용이 더 크기 때문에, 최적화에 대한 확신이 없다면 가능한 모든 곳에 메모이제이션을 활용한 최적화를 하는 것이 좋다.

<br>

## 결론 및 정리

### 학습 관점에서

실제 어느 지점에서 성능상 이점을 누릴 수 있는지 살펴보는 식으로 메모이제이션을 적용하는 것을 권장한다. 이 책의 후반부에서는 렌더링 여부를 확인하는 방법, 크롬 메모리 프로파일러를 분석하면서 state나 props의 변화에 따라 크롬 내부의 동작을 확인할 수 있는 방법도 제공한다. 이러한 방법으로 실제 성능에 어떠한 영향을 미치는지 꼼꼼하게 살펴보자.

<br>

### 현업 관점에서

의심스러운 곳에는 다 적용해 볼 것을 권장한다. 정말 간단한 함수의 경우를 제외하고, 조금이라도 로직이 들어간 컴포넌트는 메모이제이션이 성능 향상에 도움을 줄 가능성이 크다. 특히 값(함수)가 porps로 넘어가거나 이를 활용할 여지가 있다면 useMemo(useCallback)을 사용하는 것이 좋다.

<br>

(Author: 월하)